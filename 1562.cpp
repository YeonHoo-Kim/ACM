// 1562.cpp
// 계단 수
//
// 이 문제를 풀면서 느낀 점... 항상 문제좀 제대로 읽고 풀자 ㅡ.ㅡ (0에서 9가 모두 등장하는 계단 수를 구하는 문제였다...)
//
// 점화식(dp)으로 풀면 되는 문제다.
//
// 점화식은 다음과 같다.
//	     	┌ 1 		(i = 1)
// dp[i][j][k] += 	├ dp[i-1][j-1][k]	(i != 1, j > 0)
//		└ dp[i-1][j+1][k]	(i != 1, j < 9)
//
// dp[i][j][k] 의 의미는 다음과 같다.
// dp[i][j][k]의 개수에 포함된 숫자들은 모두 i자리수, 일의자리수가 j, k의 bitwise 규칙을 따른다.
// 여기서 k의 bitwise 규칙은 다음과 같다.
// 모든 수는 0~9의 숫자로 각 자리수를 나타낸다. 따라서 k를 0~1023 사이의 수로 범위를 두고 2진법으로 나타내면
// 숫자 k를 이용하여 특정 수가 어떤 숫자들을 이용했는지 표현할 수 있다. 아래와 같이 10자리의 2진수로 구분한다.
//	9       8	    7       6        5       4       3       2        1       0
//      ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
//      │      │      │      │      │      │      │      │      │      │      │	=	k
//      └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
// 사용되는 숫자는 1로 표시, 사용하지 않는 숫자는 0으로 표시한다.
//
// 예를 들어 특정 수가 12345270 이면 우리는 k를 0010111111 = 191로 표현한다.
//
// 예시
// dp[2][3][12] = 1이다.
// 2자리수이며, 3으로 끝나고(일의 자리수가 3), 12 = 1100 (2진수) 으로 2,3이 사용되었는지를 묻는다.
// 따라서 dp[2][3][12]가 가능한 수는 23만 존재하므로 1개가 된다.
//
// dp[2][3][28] = 0이다.
// 2자리수이며, 3으로 끝나고(일의 자리수가 3), 28 = 11100 (2진수) 으로 2,3,4가 사용되었는지를 묻는다.
// 따라서 dp[2][3][28]이 가능한 수는 존재하지 않기에 0개가 된다.(2자리 수인데 [2,3,4] 3개의 수를 사용할 수 없으므로)
//
// dp 문제는 매번 경험해보는 것이지만 점화식을 알면 쉽다. (이걸 찾는게 어렵지...)
//
#include<cstdio>

int dp[101][10][1024] = { 0 };

int main() {

	int N, res = 0;
	scanf("%d", &N);

	for (int j = 1; j < 10; j++)
		dp[1][j][1<<j] = 1;

	for (int i = 2; i <= N; i++) {
		for (int j = 0; j < 10; j++) {
			for (int k = 0; k < 1024; k++) {
				if (j > 0)
					dp[i][j][k | 1 << j] = (dp[i][j][k | 1 << j] + dp[i - 1][j - 1][k]) % 1000000000;
				if (j < 9)
					dp[i][j][k | 1 << j] = (dp[i][j][k | 1 << j] + dp[i - 1][j + 1][k]) % 1000000000;
			}
		}
	}

	for (int i = 0; i < 10; i++)
		res = (res + dp[N][i][1023]) % 1000000000;

	printf("%d\n", res);
	return 0;
}